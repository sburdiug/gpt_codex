# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LRiN2GYivCbNZb5hzHU4OhTHhqACO0u7
"""



import numpy as np
import matplotlib.pyplot as plt

# --- функція з варіанту 4 ---
def f(x):
    return np.sign(2 * x**3 - 4 * x) * np.abs(2 * x**3 - 4 * x)**(1/5)

# --- многочлен Лагранжа ---
def Lagrange(x, xs, ys):
    total = 0
    n = len(xs)
    for i in range(n):
        term = ys[i]
        for j in range(n):
            if i != j:
                term *= (x - xs[j]) / (xs[i] - xs[j])
        total += term
    return total

a, b = -1, 3    # h=2
n = 5          # 5 вузлів
x_nodes = np.linspace(a, b, n)
y_nodes = f(x_nodes)

# --- додаткові (середні) точки ---
x_mid = [(x_nodes[i] + x_nodes[i+1]) / 2 for i in range(len(x_nodes)-1)]

# --- об'єднані точки (вузли + середини) ---
x_all = np.unique(np.concatenate([x_nodes, np.array(x_mid)]))

y_f = [f(x) for x in x_all]
y_L = [Lagrange(x, x_nodes, y_nodes) for x in x_all]


# --- таблиця ---
print("x\ty\t\tL(x)")
print("-"*35)
for xi, fi, Li in zip(x_all, y_f, y_L):
    print(f"{xi:<.2f}\t{fi:<.6f}\t{Li:<.6f}")

# считаем кривые
x_plot = np.linspace(a - 1, b + 1, 400)
y_true = f(x_plot)
y_lagr = [Lagrange(x, x_nodes, y_nodes) for x in x_plot]



fig, ax = plt.subplots(figsize=(7, 7))      # квадратное полотно
ax.plot(x_plot, y_true, 'r', label='f(x)')
ax.plot(x_plot, y_lagr, 'b--', label='L(x) – Лагранж')
ax.scatter(x_nodes, y_nodes, color='black', zorder=5, label='вузли інтерполяції')
ax.scatter(x_all, [f(x) for x in x_all], color='red', s=40, label='f(x)')
ax.scatter(x_all, [Lagrange(x, x_nodes, y_nodes) for x in x_all],
            color='blue', marker='s', s=40, label='L(x)')

y_limit = (b - a + 4)/2  # замість L
ax.set_ylim(-y_limit, y_limit)
ax.set_xlim(a-2, b+2)
ax.set_aspect('equal', adjustable='box')

ax.grid(True)
ax.legend()

from math import factorial

# --- різниці вперед: повертає всю трикутну таблицю (як списки рядків) ---
def forward_diffs_full(y):
    y = np.asarray(y, dtype=float)
    table = [y]
    while table[-1].size > 1:
        table.append(np.diff(table[-1]))
    return table  # table[k] = Δ^k y_i, i=0..m-k

# --- перший стовпчик різниць: [Δ^0 y0, Δ^1 y0, ..., Δ^m y0] ---
def first_column_forward_diffs(y):
    table = forward_diffs_full(y)
    return np.array([row[0] for row in table], dtype=float)

def falling_fact(t, k):
    """t(t-1)...(t-k+1), FF(t,0)=1"""
    out = 1.0
    for j in range(k):
        out *= (t - j)
    return out

# --- оцінка через формулу Ньютона вперед: повертає терми N0..Nm і часткові суми L0..Lm ---
def newton_forward_terms(x, x0, h, diffs0):
    t = (x - x0)/h
    terms = []
    for k, delta in enumerate(diffs0):
        terms.append(falling_fact(t, k)/factorial(k) * delta)
    partial = np.cumsum(terms)
    return t, terms, partial  # t, [N0..Nm], [L0..Lm]

# ================= ПАРАМЕТРИ (можеш міняти) =================

xs = x_nodes
ys = y_nodes
h = xs[1] - xs[0]

# 1) Таблиця прямих різниць (як у твоєму скріні зверху)
full = forward_diffs_full(ys)
print("=== Таблиця прямих різниць (вперед) ===")
max_width = len(full[0])
headers = [f"  Δ^{k} y\t" if k>0 else "\ty" for k in range(len(full))]
print("\t".join(headers))
for i in range(max_width):
    row = []
    for k in range(len(full)):
        if i < len(full[k]):
            row.append(f"{full[k][i]: .6f}")
        else:
            row.append("")
    print("\t".join(row))
print()

# 1) коефіцієнти Ньютона (перший стовпчик різниць)
diffs0 = first_column_forward_diffs(ys)  # [Δ^0 y0, Δ^1 y0, ..., Δ^4 y0]

# 2) точки для оцінювання: вузли + середини між вузлами
x_mid = (xs[:-1] + xs[1:]) / 2
x_all = np.sort(np.unique(np.concatenate([xs, x_mid])))

# 3) акуратний друк без L-часткових сум
def fmt(v, w=10, p=6):  # вирівнювання по колонках
    return f"{v:{w}.{p}f}"

cols   = ["x",  "f(x)", "t", "N0", "N1", "N2", "N3", "N4", "N(x)"]
widths = [4, 12, 10, 12, 12, 12, 12, 14, 14]
header = " ".join(name.ljust(w) for name, w in zip(cols, widths))
print(header)
print("-"*len(header))

x0, h = xs[0], xs[1]-xs[0]
for x in x_all:
    t, terms, partial = newton_forward_terms(x, x0, h, diffs0)
    terms = (terms + [0.0]*5)[:5]      # рівно N0..N4
    Nx = partial[-1]                   # значення полінома Ньютона
    row = [
        fmt(x, widths[0]-1, 1),
        fmt(f(x), widths[1]-1, 6),
        fmt(t, widths[2]-1, 2),
        *[fmt(v, w-1, 6) for v, w in zip(terms, widths[3:8])],
        fmt(Nx, widths[8]-1, 6),

    ]
    print(" ".join(row))

# ——— крива Ньютона на щільній сітці ———
def newton_forward_value(x, x0, h, diffs0):
    _, _, partial = newton_forward_terms(x, x0, h, diffs0)
    return partial[-1]

# считаем кривые
x_plot = np.linspace(a - 1, b + 1, 400)
y_true = f(x_plot)
y_lagr = [Lagrange(x, x_nodes, y_nodes) for x in x_plot]
y_newt = np.vectorize(lambda xx: newton_forward_value(xx, x0, h, diffs0))(x_plot)


y_N_all = np.vectorize(lambda xx: newton_forward_value(xx, x0, h, diffs0))(x_all)


fig, ax = plt.subplots(figsize=(7, 7))      # квадратное полотно
ax.plot(x_plot, y_true, 'r', label='f(x)')
ax.plot(x_plot, y_lagr, 'b--', label='L(x) – Лагранж',alpha = 0.5)
ax.plot(x_plot, y_newt, 'y--', label='N(x) – Ньютона',alpha = 0.5)
ax.scatter(x_nodes, y_nodes, color='black', zorder=5, label='вузли інтерполяції')
ax.scatter(x_all, [f(x) for x in x_all], color='red', s=40, label='f(x)')
ax.scatter(x_all, [Lagrange(x, x_nodes, y_nodes) for x in x_all],
            color='blue', marker='s', s=40, label='L(x)')
ax.scatter(x_all, y_N_all,color='y', marker='s', s=40, label='N(x)')

y_limit = (b - a + 4)/2  # замість L
ax.set_ylim(-y_limit, y_limit)
ax.set_xlim(a-2, b+2)
ax.set_aspect('equal', adjustable='box')

ax.grid(True)
ax.legend()